name: demo-eks-ci

on:
  workflow_dispatch: {}
  push:
    branches: ["main"]

# Top-level env: only static values
env:
  AWS_REGION: us-east-1
  ECR_REPO: demo-app
  NAMESPACE: default

permissions:
  id-token: write
  contents: read

jobs:

  terraform:
    name: Terraform Infra
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Set dynamic variables (EKS cluster name + TF var)
        run: |
          echo "EKS_CLUSTER=demo-eks-${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV
          echo "TF_VAR_cluster_name=demo-eks-${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV
          echo "Using cluster: demo-eks-${GITHUB_RUN_NUMBER}"

      - name: Terraform init
        working-directory: infra
        run: terraform init -upgrade

      - name: Pre-clean ECR repo & residual CW log group
        env:
          AWS_REGION:  ${{ env.AWS_REGION }}
        run: |
          set -e
          echo "Cluster (from env): $EKS_CLUSTER"
          echo "Checking existing ECR repo: ${{ env.ECR_REPO }}"
          if aws ecr describe-repositories --repository-names "${{ env.ECR_REPO }}" --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "Deleting existing ECR repo..."
            aws ecr delete-repository --repository-name "${{ env.ECR_REPO }}" --force --region "$AWS_REGION" || true
          fi

          if aws logs describe-log-groups --log-group-name-prefix "/aws/eks/${EKS_CLUSTER}/cluster" --region "$AWS_REGION" \
             | grep -q "/aws/eks/${EKS_CLUSTER}/cluster"; then
            echo "Deleting old CloudWatch log group /aws/eks/${EKS_CLUSTER}/cluster ..."
            aws logs delete-log-group --log-group-name "/aws/eks/${EKS_CLUSTER}/cluster" --region "$AWS_REGION" || true
          fi

      - name: Terraform apply
        working-directory: infra
        run: terraform apply -auto-approve


  build_and_push:
    name: Build & Push Image
    runs-on: ubuntu-latest
    needs: terraform

    outputs:
      image_uri: ${{ steps.push.outputs.image_uri }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Set dynamic variables (EKS cluster name)
        run: |
          echo "EKS_CLUSTER=demo-eks-${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV
          echo "Using cluster: demo-eks-${GITHUB_RUN_NUMBER}"

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push
        id: push
        env:
          REGISTRY:  ${{ steps.ecr.outputs.registry }}
          IMAGE_TAG: latest
        run: |
          set -e
          IMAGE_URI="$REGISTRY/${{ env.ECR_REPO }}:$IMAGE_TAG"
          echo "Building image: $IMAGE_URI"
          docker build -t "$IMAGE_URI" ./app
          docker push "$IMAGE_URI"
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT


  deploy:
    name: Install Ingress & Deploy App
    runs-on: ubuntu-latest
    needs: build_and_push

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Set dynamic variables (EKS cluster name)
        run: |
          echo "EKS_CLUSTER=demo-eks-${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV
          echo "Using cluster: demo-eks-${GITHUB_RUN_NUMBER}"

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.29.6"

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name "${EKS_CLUSTER}" --region "${{ env.AWS_REGION }}"

      - name: Wait for EKS cluster ACTIVE
        run: aws eks wait cluster-active --name "${EKS_CLUSTER}" --region "${{ env.AWS_REGION }}"

      - name: Wait for API /readyz
        run: |
          for i in {1..60}; do
            if kubectl get --raw='/readyz?verbose' >/dev/null 2>&1; then
              echo "API server fully ready"
              break
            fi
            echo "Waiting for API /readyz ($i/60)"
            sleep 5
          done

      - name: Wait for at least one Ready node
        run: |
          for i in {1..40}; do
            READY=$(kubectl get nodes --no-headers 2>/dev/null | awk '{print $2}' | grep -c '^Ready$' || true)
            if [ "$READY" -ge 1 ]; then
              echo "Node ready"
              kubectl get nodes
              break
            fi
            echo "Waiting for node Ready ($i/40)"
            sleep 10
          done

      - name: Install ingress-nginx (retry)
        run: |
          set -e
          URL="https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/aws/deploy.yaml"
          echo "Installing ingress-nginx with retry..."
          for i in {1..5}; do
            if kubectl apply --validate=false -f "$URL"; then
              echo "Ingress applied OK"
              break
            fi
            echo "Retry $i/5 failed; sleeping 10s..."
            sleep 10
          done
          kubectl rollout status deployment/ingress-nginx-controller -n ingress-nginx --timeout=900s

      - name: Deploy app manifests
        env:
          IMAGE_URI: ${{ needs.build_and_push.outputs.image_uri }}
        run: |
          set -e
          sed "s|REPLACE_IMAGE|$IMAGE_URI|g" app/k8s/deployment.yaml \
            | kubectl apply --validate=false -n "${{ env.NAMESPACE }}" -f -
          kubectl apply --validate=false -n "${{ env.NAMESPACE }}" -f app/k8s/service.yaml
          kubectl apply --validate=false -n "${{ env.NAMESPACE }}" -f app/k8s/ingress.yaml

      - name: Wait for app rollout
        run: kubectl rollout status deployment/demo-app -n "${{ env.NAMESPACE }}" --timeout=600s

      - name: Show ingress & NGINX LB
        run: |
          kubectl get ingress -n "${{ env.NAMESPACE }}"
          kubectl get svc -n ingress-nginx